<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Modeling Conecpts · OpPoDyn.jl</title><meta name="title" content="Modeling Conecpts · OpPoDyn.jl"/><meta property="og:title" content="Modeling Conecpts · OpPoDyn.jl"/><meta property="twitter:title" content="Modeling Conecpts · OpPoDyn.jl"/><meta name="description" content="Documentation for OpPoDyn.jl."/><meta property="og:description" content="Documentation for OpPoDyn.jl."/><meta property="twitter:description" content="Documentation for OpPoDyn.jl."/><meta property="og:url" content="https://juliaenergy.github.io/OpPoDyn.jl/ModelingConcepts/"/><meta property="twitter:url" content="https://juliaenergy.github.io/OpPoDyn.jl/ModelingConcepts/"/><link rel="canonical" href="https://juliaenergy.github.io/OpPoDyn.jl/ModelingConcepts/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">OpPoDyn.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Modeling Conecpts</a><ul class="internal"><li><a class="tocitem" href="#Terminal"><span>Terminal</span></a></li><li><a class="tocitem" href="#Modeling-of-Buses"><span>Modeling of Buses</span></a></li><li><a class="tocitem" href="#Line-Modeling"><span>Line Modeling</span></a></li><li><a class="tocitem" href="#From-MTK-Models-to-NetworkDynamics"><span>From MTK Models to NetworkDynamics</span></a></li><li><a class="tocitem" href="#Internals"><span>Internals</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Modeling Conecpts</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Modeling Conecpts</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaEnergy/OpPoDyn.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaEnergy/OpPoDyn.jl/blob/main/docs/src/ModelingConcepts.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Modeling-Concepts"><a class="docs-heading-anchor" href="#Modeling-Concepts">Modeling Concepts</a><a id="Modeling-Concepts-1"></a><a class="docs-heading-anchor-permalink" href="#Modeling-Concepts" title="Permalink"></a></h1><h2 id="Terminal"><a class="docs-heading-anchor" href="#Terminal">Terminal</a><a id="Terminal-1"></a><a class="docs-heading-anchor-permalink" href="#Terminal" title="Permalink"></a></h2><p>The <code>Terminal</code>─Connector is an important building block for every model. It represents a connection point with constant voltage in dq─cordinates <code>u_r</code> and <code>u_i</code> and enforces the kirchoff constraints <code>sum(i_r)=0</code> and <code>sum(i_i)=0</code>.</p><h2 id="Modeling-of-Buses"><a class="docs-heading-anchor" href="#Modeling-of-Buses">Modeling of Buses</a><a id="Modeling-of-Buses-1"></a><a class="docs-heading-anchor-permalink" href="#Modeling-of-Buses" title="Permalink"></a></h2><h3 id="Model-class-Injector"><a class="docs-heading-anchor" href="#Model-class-Injector">Model class <code>Injector</code></a><a id="Model-class-Injector-1"></a><a class="docs-heading-anchor-permalink" href="#Model-class-Injector" title="Permalink"></a></h3><p>An injector is a class of components with a single <code>Terminal()</code> (called <code>:terminal</code>). Examples for injectors might be Generators, Shunts, Loads.</p><pre><code class="nohighlight hljs">      ┌───────────┐
(t)   │           │
 o←───┤  Injector │
      │           │
      └───────────┘</code></pre><p>The current for injectors is always in injector convention, i.e. positive currents flow <em>out</em> of the injector <em>towards</em> the terminal.</p><div class="admonition is-info"><header class="admonition-header">Model classes</header><div class="admonition-body"><p>Model &quot;classes&quot; are nothing formalized. In this document, a model class is just a description for some <code>ODESystem</code> from <code>ModelingToolkit.jl</code>, which satisfies certain requirements. For example, any <code>ODESystem</code> is considered an &quot;Injector&quot; if it contains a connector <code>Terminal()</code> called <code>:terminal</code>.</p></div></div><details class="admonition is-details"><summary class="admonition-header">Code example: definition of PQ load as injector</summary><div class="admonition-body"><pre><code class="language-example hljs">using OpPoDyn, OpPoDyn.Library, ModelingToolkit
@mtkmodel MyPQLoad begin
    @components begin
        terminal = Terminal()
    end
    @parameters begin
        Pset, [description=&quot;Active Power demand&quot;]
        Qset, [description=&quot;Reactive Power demand&quot;]
    end
    @variables begin
        P(t), [description=&quot;Active Power&quot;]
        Q(t), [description=&quot;Reactive Power&quot;]
    end
    @equations begin
        P ~ terminal.u_r*terminal.i_r + terminal.u_i*terminal.i_i
        Q ~ terminal.u_i*terminal.i_r - terminal.u_r*terminal.i_i
        # if possible, its better for the solver to explicitly provide algebraic equations for the current
        terminal.i_r ~ (Pset*terminal.u_r + Qset*terminal.u_i)/(terminal.u_r^2 + terminal.u_i^2)
        terminal.i_i ~ (Pset*terminal.u_i - Qset*terminal.u_r)/(terminal.u_r^2 + terminal.u_i^2)
    end
end
nothing #hide</code></pre></div></details><h3 id="Model-class-MTKBus"><a class="docs-heading-anchor" href="#Model-class-MTKBus">Model class <code>MTKBus</code></a><a id="Model-class-MTKBus-1"></a><a class="docs-heading-anchor-permalink" href="#Model-class-MTKBus" title="Permalink"></a></h3><p>A <code>MTKBus</code> isa class of models, which are used to describe the dynamic behavior of a full bus in a power grid. Each <code>MTKBus</code> musst contain a predefined model of type <code>BusBar()</code> (named <code>:busbar</code>). This busbar represents the connection point to the grid. Optionally, it may contain various injectors.</p><pre><code class="nohighlight hljs"> ┌───────────────────────────────────┐
 │ MTKBus             ┌───────────┐  │
 │  ┌──────────┐   o──┤ Generator │  │
 │  │          │   │  └───────────┘  │
 │  │  BusBar  ├───o                 │
 │  │          │   │  ┌───────────┐  │
 │  └──────────┘   o──│ Load      │  │
 │                    └───────────┘  │
 └───────────────────────────────────┘</code></pre><p>Sometimes it is not possible to connect all injectors directly but instead one needs or wants <code>Branches</code> between the busbar and injector terminal. As long as the <code>:busbar</code> is present at the toplevel, there are few limitations on the overall model complexity.</p><p>For simple models (direct connections of a few injectors) it is possible to use the convenience method <code>MTKBus(injectors...)</code> to create the composite model based on provide injector models.</p><details class="admonition is-details"><summary class="admonition-header">Code example: definition of a Bus containing a swing equation and a load</summary><div class="admonition-body"><pre><code class="language-example hljs">using OpPoDyn, OpPoDyn.Library, ModelingToolkit
@mtkmodel MyMTKBus begin
    @components begin
        busbar = BusBar()
        swing = Swing()
        laod = PQLoad()
    end
    @equations begin
        connect(busbar.terminal, swing.terminal)
        connect(busbar.terminal, load.terminal)
    end
end
nothing #hide</code></pre><p>Alternativly, for that system you could have just called</p><pre><code class="language-example hljs">mybus = MTKBus(Swing(;name=:swing), PQLoad(;name=:load))
nothing #hide</code></pre><p>to get an instance of a model which is structually aquivalent to <code>MyMTKBus</code>.</p></div></details><h2 id="Line-Modeling"><a class="docs-heading-anchor" href="#Line-Modeling">Line Modeling</a><a id="Line-Modeling-1"></a><a class="docs-heading-anchor-permalink" href="#Line-Modeling" title="Permalink"></a></h2><h3 id="Model-class-Branch"><a class="docs-heading-anchor" href="#Model-class-Branch">Model class <code>Branch</code></a><a id="Model-class-Branch-1"></a><a class="docs-heading-anchor-permalink" href="#Model-class-Branch" title="Permalink"></a></h3><p>A branch is the two-port equivalent to an injector. I needs to have two <code>Terminal()</code>s, one is called <code>:src</code>, the other <code>:dst</code>.</p><p>Examples for branches are: PI─Model branches, dynamic RL branches or transformers.</p><pre><code class="nohighlight hljs">      ┌───────────┐
(src) │           │ (dst)
  o←──┤  Branch   ├──→o
      │           │
      └───────────┘</code></pre><p><em>Both</em> ends follow the injector interface, i.e. current leaving the device towards the terminals is always positive.</p><details class="admonition is-details"><summary class="admonition-header">Code example: algebraic R-line</summary><div class="admonition-body"><pre><code class="language-julia hljs">using OpPoDyn, OpPoDyn.Library, ModelingToolkit
@mtkmodel MyRLine begin
    @components begin
        src = Terminal()
        dst = Terminal()
    end
    @parameters begin
        R=0, [description=&quot;Resistance&quot;]
    end
    @equations begin
        dst.i_r ~ (dst.u_r - src.u_r)/R
        dst.i_i ~ (dst.u_i - src.u_i)/R
        src.i_r ~ -dst.i_r
        src.i_i ~ -dst.i_i
    end
end</code></pre></div></details><h3 id="Model-class:-MTKLine"><a class="docs-heading-anchor" href="#Model-class:-MTKLine">Model class: <code>MTKLine</code></a><a id="Model-class:-MTKLine-1"></a><a class="docs-heading-anchor-permalink" href="#Model-class:-MTKLine" title="Permalink"></a></h3><p>Similar to the <code>MTKBus</code>, a <code>MTKLine</code> is a model class which represents a transmission line in the network.</p><p>It musst contain two <code>LineEnd()</code> instances, one called <code>:src</code>, one called <code>:dst</code>.</p><pre><code class="nohighlight hljs"> ┌────────────────────────────────────────────────┐
 │ MTKLine          ┌──────────┐                  │
 │  ┌─────────┐  o──┤ Branch A │──o  ┌─────────┐  │
 │  │ LineEnd │  │  └──────────┘  │  │ LineEnd │  │
 │  │  :src   ├──o                o──┤  :dst   │  │
 │  │         │  │  ┌──────────┐  │  │         │  │
 │  └─────────┘  o──┤ Branch B │──o  └─────────┘  │
 │                  └──────────┘                  │
 └────────────────────────────────────────────────┘</code></pre><p>Simple line models, which consist only of valid <code>Branch</code> models can be instantiated using the <code>MTKLine(branches...)</code> constructor.</p><p>More complex models can be created manually. For example if you want to chain multiple branches between the <code>LineEnds</code>, for example something like</p><pre><code class="nohighlight hljs">LineEnd(:src) ──o── Transformer ──o── Pi─Line ──o── LineEnd(:dst)</code></pre><details class="admonition is-details"><summary class="admonition-header">Code example: Transmission line with two pi-branches</summary><div class="admonition-body"><pre><code class="language-example hljs">using OpPoDyn, OpPoDyn.Library, ModelingToolkit
@mtkmodel MyMTKLine begin
    @components begin
        src = LineEnd()
        dst = LineEnd()
        branch1 = DynawoPiLine()
        branch2 = DynawoPiLine()
    end
    @equations begin
        connect(src.terminal, branch1.src)
        connect(src.terminal, branch2.src)
        connect(dst.terminal, branch1.dst)
        connect(dst.terminal, branch2.dst)
    end
end
nothing #hide</code></pre><p>Alternatively, an equivalent model with multiple valid branch models in parallel could be created and instantiated with the convenience constructor</p><pre><code class="language-example hljs">line = MTKLine(DynawoPiLine(;name=:branch1), DynawoPiLine(;name=:branch2))
nothing #hide</code></pre></div></details><h2 id="From-MTK-Models-to-NetworkDynamics"><a class="docs-heading-anchor" href="#From-MTK-Models-to-NetworkDynamics">From MTK Models to NetworkDynamics</a><a id="From-MTK-Models-to-NetworkDynamics-1"></a><a class="docs-heading-anchor-permalink" href="#From-MTK-Models-to-NetworkDynamics" title="Permalink"></a></h2><p>Valid <code>MTKLine</code> and <code>MTKBus</code> can be transformed into so called <code>Line</code> and <code>Bus</code> objects.</p><p><code>Line</code> and <code>Bus</code> structs are no MTK models anymore, but rather containers. Currently, they mainly contain a NetworkDynamics component function (<code>ODEVertex</code>, <code>StaticEdge</code>).</p><p>Eventually, those models will contain more metadata. For example</p><ul><li>static representation for powerflow,</li><li>possibly local information about PU system (for transforming parameters between SI/PU),</li><li>meta information for initialization, for example initialization model or the information which parameters are considered &quot;tunable&quot; in order to initialize the dynamical model</li></ul><p>The exact structure here is not clear yet!</p><p>The result would look something like that:</p><pre><code class="language-example hljs">using OpPoDyn, OpPoDyn.Library, ModelingToolkit
using Graphs, NetworkDynamics
using OrdinaryDiffEqRosenbrock, OrdinaryDiffEqNonlinearSolve
using CairoMakie
nothing #hide</code></pre><p>Define a swing bus with load</p><pre><code class="language-example hljs"># define injectors
@named swing = Swing(; Pm=1)
@named load = PQLoad(; Pset=-.5, Qset=0)
bus1mtk = MTKBus(swing, load; name=:swingbus)
bus1 = Bus(bus1mtk)
vertex1f = bus1.compf # extract component function</code></pre><p>Define a second bus as a slack</p><pre><code class="language-example hljs">bus2mtk = SlackDifferential(; name=:slackbus)
bus2 = Bus(bus2mtk)
vertex2f = bus2.compf # extract component function</code></pre><p>Define the powerline connecting both nodes</p><pre><code class="language-example hljs">@named branch1 = DynawoPiLine()
@named branch2 = DynawoPiLine()
linemtk = MTKLine(branch1, branch2; name=:powerline)
line = Line(linemtk)
edgef = line.compf # extract component function</code></pre><p>Define the graph, the network and extract initial conditions</p><pre><code class="language-example hljs">g = complete_graph(2)
nw = Network(g, [vertex1f, vertex2f], edgef)
u0 = NWState(nw) # extract parameters and state from modesl</code></pre><p>Then we can solve the problem</p><pre><code class="language-example hljs">prob = ODEProblem(nw, uflat(u0), (0,1), pflat(u0))
sol = solve(prob, Rodas5P())
nothing #hide</code></pre><p>And finally we can plot the solution:</p><pre><code class="language-example hljs">fig = Figure();
ax = Axis(fig[1,1])
lines!(ax, sol; idxs=VIndex(1,:busbar₊P), label=&quot;Power injection Bus&quot;, color=Cycled(1))
lines!(ax, sol; idxs=VIndex(1,:swing₊Pel), label=&quot;Power injection Swing&quot;, color=Cycled(2))
lines!(ax, sol; idxs=VIndex(1,:load₊P), label=&quot;Power injection load&quot;, color=Cycled(3))
axislegend(ax)

ax = Axis(fig[2,1])
lines!(ax, sol; idxs=VIndex(1,:busbar₊u_arg), label=&quot;swing bus voltage angle&quot;, color=Cycled(1))
lines!(ax, sol; idxs=VIndex(2,:busbar₊u_arg), label=&quot;slack bus voltage angle&quot;, color=Cycled(2))
axislegend(ax)
fig #hide</code></pre><h2 id="Internals"><a class="docs-heading-anchor" href="#Internals">Internals</a><a id="Internals-1"></a><a class="docs-heading-anchor-permalink" href="#Internals" title="Permalink"></a></h2><p>Internally, we use different input/output conventions for bus and line models. The predefined models <code>BusBar()</code> and <code>LineEnd()</code> are defined in the following way:</p><h3 id="Model:-BusBar()"><a class="docs-heading-anchor" href="#Model:-BusBar()">Model: <code>BusBar()</code></a><a id="Model:-BusBar()-1"></a><a class="docs-heading-anchor-permalink" href="#Model:-BusBar()" title="Permalink"></a></h3><p>A busbar is a concrete model used in bus modeling. It represents the physical connection within a bus, the thing where all injectors and lines attach.</p><pre><code class="nohighlight hljs">           ┌──────────┐
i_lines ──→│          │  (t)
           │  Busbar  ├───o
  u_bus ←──│          │
           └──────────┘</code></pre><p>It receives the sum of all line currents as an input and equals that to the currents flowing into the terminal. As an output, it gives forwards the terminal voltage to the backend.</p><h3 id="Model:-LineEnd()"><a class="docs-heading-anchor" href="#Model:-LineEnd()">Model: <code>LineEnd()</code></a><a id="Model:-LineEnd()-1"></a><a class="docs-heading-anchor-permalink" href="#Model:-LineEnd()" title="Permalink"></a></h3><p>A <code>LineEnd</code> model is very similar to the <code>BusBar</code> model. It represents one end of a transmission line.</p><pre><code class="nohighlight hljs">          ┌───────────┐
 u_bus ──→│           │  (t)
          │ LineEnd   ├───o
i_line ←──│           │
          └───────────┘</code></pre><p>It has special input/output connectors which handle the network interconnection. The main difference beeing the different input/output conventions for the network interface.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Wednesday 18 September 2024 13:53">Wednesday 18 September 2024</span>. Using Julia version 1.11.0-rc3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
